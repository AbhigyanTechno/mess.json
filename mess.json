
{
  "name": "easymess-backend",
  "version": "1.0.0",
  "description": "Backend for EasyMess - Smart Mess Management System",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js",
    "test": "jest"
  },
  "dependencies": {
    "express": "^4.18.2",
    "mongoose": "^7.5.0",
    "bcryptjs": "^2.4.3",
    "jsonwebtoken": "^9.0.2",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "express-validator": "^7.0.1",
    "multer": "^1.4.5-lts.1",
    "nodemailer": "^6.9.4",
    "helmet": "^7.0.0",
    "express-rate-limit": "^6.10.0"
  },
  "devDependencies": {
    "nodemon": "^3.0.1",
    "jest": "^29.6.2"
  },
  "author": "Team Sher E Hind",
  "license": "MIT"
}


const express = require('express');
const mongoose = require('mongoose');
const cors = require('cors');
const helmet = require('helmet');
const rateLimit = require('express-rate-limit');
require('dotenv').config();

const authRoutes = require('./routes/auth');
const userRoutes = require('./routes/users');
const mealRoutes = require('./routes/meals');
const menuRoutes = require('./routes/menu');
const paymentRoutes = require('./routes/payments');
const feedbackRoutes = require('./routes/feedback');

const app = express();

// Security middleware
app.use(helmet());

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100 // limit each IP to 100 requests per windowMs
});
app.use(limiter);

// CORS configuration
app.use(cors({
  origin: process.env.FRONTEND_URL || 'http://localhost:3000',
  credentials: true
}));

// Body parser middleware
app.use(express.json({ limit: '10mb' }));
app.use(express.urlencoded({ extended: true }));

// MongoDB connection
mongoose.connect(process.env.MONGODB_URI || 'mongodb://localhost:27017/easymess', {
  useNewUrlParser: true,
  useUnifiedTopology: true,
})
.then(() => console.log('✅ MongoDB connected successfully'))
.catch(err => console.error('❌ MongoDB connection error:', err));

// Routes
app.use('/api/auth', authRoutes);
app.use('/api/users', userRoutes);
app.use('/api/meals', mealRoutes);
app.use('/api/menu', menuRoutes);
app.use('/api/payments', paymentRoutes);
app.use('/api/feedback', feedbackRoutes);

// Health check endpoint
app.get('/api/health', (req, res) => {
  res.status(200).json({
    status: 'success',
    message: 'EasyMess Backend is running!',
    timestamp: new Date().toISOString(),
    team: 'Sher E Hind'
  });
});

// Error handling middleware
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({
    status: 'error',
    message: 'Something went wrong!',
    error: process.env.NODE_ENV === 'development' ? err.message : {}
  });
});

// 404 handler
app.use('*', (req, res) => {
  res.status(404).json({
    status: 'error',
    message: 'Route not found'
  });
});

const PORT = process.env.PORT || 5000;
app.listen(PORT, () => {
  console.log(🚀 Server running on port ${PORT});
  console.log(📊 Environment: ${process.env.NODE_ENV || 'development'});
});

// models/User.js
const mongoose = require('mongoose');
const bcrypt = require('bcryptjs');

const userSchema = new mongoose.Schema({
  studentId: {
    type: String,
    required: true,
    unique: true,
    trim: true
  },
  name: {
    type: String,
    required: true,
    trim: true
  },
  email: {
    type: String,
    required: true,
    unique: true,
    lowercase: true,
    trim: true
  },
  password: {
    type: String,
    required: true,
    minlength: 6
  },
  role: {
    type: String,
    enum: ['student', 'staff', 'admin'],
    default: 'student'
  },
  hostel: {
    type: String,
    required: true
  },
  roomNumber: {
    type: String,
    required: true
  },
  phoneNumber: {
    type: String,
    required: true
  },
  messBalance: {
    type: Number,
    default: 0
  },
  isActive: {
    type: Boolean,
    default: true
  },
  dietaryPreferences: [{
    type: String,
    enum: ['vegetarian', 'non-vegetarian', 'vegan', 'jain', 'no-onion-garlic']
  }],
  allergies: [String],
  joinedDate: {
    type: Date,
    default: Date.now
  }
}, {
  timestamps: true
});

// Hash password before saving
userSchema.pre('save', async function(next) {
  if (!this.isModified('password')) return next();
  
  try {
    const salt = await bcrypt.genSalt(12);
    this.password = await bcrypt.hash(this.password, salt);
    next();
  } catch (error) {
    next(error);
  }
});

// Compare password method
userSchema.methods.comparePassword = async function(candidatePassword) {
  return await bcrypt.compare(candidatePassword, this.password);
};

module.exports = mongoose.model('User', userSchema);

// models/Menu.js
const mongoose = require('mongoose');

const menuItemSchema = new mongoose.Schema({
  name: {
    type: String,
    required: true
  },
  description: String,
  category: {
    type: String,
    enum: ['breakfast', 'lunch', 'dinner', 'snacks'],
    required: true
  },
  isVegetarian: {
    type: Boolean,
    default: true
  },
  calories: Number,
  price: {
    type: Number,
    required: true
  }
});

const menuSchema = new mongoose.Schema({
  date: {
    type: Date,
    required: true,
    unique: true
  },
  breakfast: [menuItemSchema],
  lunch: [menuItemSchema],
  dinner: [menuItemSchema],
  specialInstructions: String,
  createdBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  }
}, {
  timestamps: true
});

module.exports = mongoose.model('Menu', menuSchema);

// models/MealBooking.js
const mongoose = require('mongoose');

const mealBookingSchema = new mongoose.Schema({
  user: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  date: {
    type: Date,
    required: true
  },
  breakfast: {
    booked: { type: Boolean, default: false },
    attended: { type: Boolean, default: false },
    bookedAt: Date,
    attendedAt: Date
  },
  lunch: {
    booked: { type: Boolean, default: false },
    attended: { type: Boolean, default: false },
    bookedAt: Date,
    attendedAt: Date
  },
  dinner: {
    booked: { type: Boolean, default: false },
    attended: { type: Boolean, default: false },
    bookedAt: Date,
    attendedAt: Date
  },
  totalAmount: {
    type: Number,
    default: 0
  }
}, {
  timestamps: true
});

// Compound index for user and date
mealBookingSchema.index({ user: 1, date: 1 }, { unique: true });

module.exports = mongoose.model('MealBooking', mealBookingSchema);

// models/Payment.js
const mongoose = require('mongoose');

const paymentSchema = new mongoose.Schema({
  user: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  amount: {
    type: Number,
    required: true
  },
  type: {
    type: String,
    enum: ['mess_fee', 'extra_meal', 'fine', 'refund'],
    required: true
  },
  status: {
    type: String,
    enum: ['pending', 'completed', 'failed', 'refunded'],
    default: 'pending'
  },
  paymentMethod: {
    type: String,
    enum: ['cash', 'upi', 'card', 'net_banking'],
    required: true
  },
  transactionId: {
    type: String,
    unique: true,
    sparse: true
  },
  description: String,
  month: {
    type: String,
    required: true // Format: "YYYY-MM"
  },
  processedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  }
}, {
  timestamps: true
});

module.exports = mongoose.model('Payment', paymentSchema);

// models/Feedback.js
const mongoose = require('mongoose');

const feedbackSchema = new mongoose.Schema({
  user: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User',
    required: true
  },
  type: {
    type: String,
    enum: ['complaint', 'suggestion', 'compliment', 'menu_request'],
    required: true
  },
  category: {
    type: String,
    enum: ['food_quality', 'service', 'cleanliness', 'staff_behavior', 'menu', 'other'],
    required: true
  },
  title: {
    type: String,
    required: true,
    trim: true
  },
  description: {
    type: String,
    required: true
  },
  rating: {
    type: Number,
    min: 1,
    max: 5
  },
  status: {
    type: String,
    enum: ['open', 'in_progress', 'resolved', 'closed'],
    default: 'open'
  },
  response: {
    message: String,
    respondedBy: {
      type: mongoose.Schema.Types.ObjectId,
      ref: 'User'
    },
    respondedAt: Date
  },
  priority: {
    type: String,
    enum: ['low', 'medium', 'high', 'urgent'],
    default: 'medium'
  }
}, {
  timestamps: true
});

module.exports = mongoose.model('Feedback', feedbackSchema);

// middleware/auth.js
const jwt = require('jsonwebtoken');
const User = require('../models/User');

const auth = async (req, res, next) => {
  try {
    const token = req.header('Authorization')?.replace('Bearer ', '');
    
    if (!token) {
      return res.status(401).json({
        status: 'error',
        message: 'Access denied. No token provided.'
      });
    }

    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    const user = await User.findById(decoded.userId).select('-password');
    
    if (!user || !user.isActive) {
      return res.status(401).json({
        status: 'error',
        message: 'Invalid token or user not active.'
      });
    }

    req.user = user;
    next();
  } catch (error) {
    res.status(401).json({
      status: 'error',
      message: 'Invalid token.'
    });
  }
};

// Role-based access control
const authorize = (...roles) => {
  return (req, res, next) => {
    if (!roles.includes(req.user.role)) {
      return res.status(403).json({
        status: 'error',
        message: 'Access denied. Insufficient permissions.'
      });
    }
    next();
  };
};

module.exports = { auth, authorize };

// routes/auth.js
const express = require('express');
const jwt = require('jsonwebtoken');
const { body, validationResult } = require('express-validator');
const User = require('../models/User');
const { auth } = require('../middleware/auth');

const router = express.Router();

// Generate JWT token
const generateToken = (userId) => {
  return jwt.sign(
    { userId },
    process.env.JWT_SECRET || 'easymess_secret_key',
    { expiresIn: '7d' }
  );
};

// @route   POST /api/auth/register
// @desc    Register a new user
// @access  Public
router.post('/register', [
  body('studentId').notEmpty().withMessage('Student ID is required'),
  body('name').notEmpty().withMessage('Name is required'),
  body('email').isEmail().withMessage('Valid email is required'),
  body('password').isLength({ min: 6 }).withMessage('Password must be at least 6 characters'),
  body('hostel').notEmpty().withMessage('Hostel is required'),
  body('roomNumber').notEmpty().withMessage('Room number is required'),
  body('phoneNumber').isMobilePhone().withMessage('Valid phone number is required')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        status: 'error',
        message: 'Validation failed',
        errors: errors.array()
      });
    }

    const { studentId, name, email, password, hostel, roomNumber, phoneNumber, role } = req.body;

    // Check if user already exists
    const existingUser = await User.findOne({
      $or: [{ email }, { studentId }]
    });

    if (existingUser) {
      return res.status(400).json({
        status: 'error',
        message: 'User already exists with this email or student ID'
      });
    }

    // Create new user
    const user = new User({
      studentId,
      name,
      email,
      password,
      hostel,
      roomNumber,
      phoneNumber,
      role: role || 'student',
      messBalance: 0
    });

    await user.save();

    // Generate token
    const token = generateToken(user._id);

    res.status(201).json({
      status: 'success',
      message: 'User registered successfully',
      data: {
        token,
        user: {
          id: user._id,
          studentId: user.studentId,
          name: user.name,
          email: user.email,
          role: user.role,
          hostel: user.hostel,
          roomNumber: user.roomNumber,
          messBalance: user.messBalance
        }
      }
    });
  } catch (error) {
    console.error('Registration error:', error);
    res.status(500).json({
      status: 'error',
      message: 'Server error during registration'
    });
  }
});

// @route   POST /api/auth/login
// @desc    Login user
// @access  Public
router.post('/login', [
  body('identifier').notEmpty().withMessage('Student ID or email is required'),
  body('password').notEmpty().withMessage('Password is required')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        status: 'error',
        message: 'Validation failed',
        errors: errors.array()
      });
    }

    const { identifier, password } = req.body;

    // Find user by student ID or email
    const user = await User.findOne({
      $or: [
        { email: identifier.toLowerCase() },
        { studentId: identifier }
      ]
    });

    if (!user || !user.isActive) {
      return res.status(401).json({
        status: 'error',
        message: 'Invalid credentials or account inactive'
      });
    }

    // Check password
    const isPasswordValid = await user.comparePassword(password);
    if (!isPasswordValid) {
      return res.status(401).json({
        status: 'error',
        message: 'Invalid credentials'
      });
    }

    // Generate token
    const token = generateToken(user._id);

    res.json({
      status: 'success',
      message: 'Login successful',
      data: {
        token,
        user: {
          id: user._id,
          studentId: user.studentId,
          name: user.name,
          email: user.email,
          role: user.role,
          hostel: user.hostel,
          roomNumber: user.roomNumber,
          messBalance: user.messBalance,
          dietaryPreferences: user.dietaryPreferences
        }
      }
    });
  } catch (error) {
    console.error('Login error:', error);
    res.status(500).json({
      status: 'error',
      message: 'Server error during login'
    });
  }
});

// @route   GET /api/auth/me
// @desc    Get current user info
// @access  Private
router.get('/me', auth, async (req, res) => {
  try {
    const user = await User.findById(req.user._id).select('-password');
    
    res.json({
      status: 'success',
      data: {
        user: {
          id: user._id,
          studentId: user.studentId,
          name: user.name,
          email: user.email,
          role: user.role,
          hostel: user.hostel,
          roomNumber: user.roomNumber,
          phoneNumber: user.phoneNumber,
          messBalance: user.messBalance,
          dietaryPreferences: user.dietaryPreferences,
          allergies: user.allergies,
          joinedDate: user.joinedDate
        }
      }
    });
  } catch (error) {
    console.error('Get user error:', error);
    res.status(500).json({
      status: 'error',
      message: 'Server error'
    });
  }
});

module.exports = router;

// routes/meals.js
const express = require('express');
const { body, validationResult } = require('express-validator');
const MealBooking = require('../models/MealBooking');
const Menu = require('../models/Menu');
const { auth, authorize } = require('../middleware/auth');

const router = express.Router();

// @route   POST /api/meals/book
// @desc    Book meals for a date
// @access  Private (Student)
router.post('/book', [
  auth,
  body('date').isISO8601().withMessage('Valid date is required'),
  body('meals').isObject().withMessage('Meals object is required')
], async (req, res) => {
  try {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      return res.status(400).json({
        status: 'error',
        message: 'Validation failed',
        errors: errors.array()
      });
    }

    const { date, meals } = req.body;
    const userId = req.user._id;

    // Check if booking already exists for this date
    let booking = await MealBooking.findOne({
      user: userId,
      date: new Date(date)
    });

    if (booking) {
      // Update existing booking
      if (meals.breakfast !== undefined) {
        booking.breakfast.booked = meals.breakfast;
        if (meals.breakfast) booking.breakfast.bookedAt = new Date();
      }
      if (meals.lunch !== undefined) {
        booking.lunch.booked = meals.lunch;
        if (meals.lunch) booking.lunch.bookedAt = new Date();
      }
      if (meals.dinner !== undefined) {
        booking.dinner.booked = meals.dinner;
        if (meals.dinner) booking.dinner.bookedAt = new Date();
      }
    } else {
      // Create new booking
      booking = new MealBooking({
        user: userId,
        date: new Date(date),
        breakfast: {
          booked: meals.breakfast || false,
          bookedAt: meals.breakfast ? new Date() : null
        },
        lunch: {
          booked: meals.lunch || false,
          bookedAt: meals.lunch ? new Date() : null
        },
        dinner: {
          booked: meals.dinner || false,
          bookedAt: meals.dinner ? new Date() : null
        }
      });
    }

    // Calculate total amount (assuming fixed prices)
    const prices = { breakfast: 30, lunch: 60, dinner: 50 };
    booking.totalAmount = 
      (booking.breakfast.booked ? prices.breakfast : 0) +
      (booking.lunch.booked ? prices.lunch : 0) +
      (booking.dinner.booked ? prices.dinner : 0);

    await booking.save();

    res.json({
      status: 'success',
      message: 'Meals booked successfully',
      data: { booking }
    });
  } catch (error) {
    console.error('Meal booking error:', error);
    res.status(500).json({
      status: 'error',
      message: 'Server error during meal booking'
    });
  }
});

// @route   GET /api/meals/bookings
// @desc    Get user's meal bookings
// @access  Private
router.get('/bookings', auth, async (req, res) => {
  try {
    const { startDate, endDate, page = 1, limit = 10 } = req.query;
    
    const query = { user: req.user._id };
    
    if (startDate && endDate) {
      query.date = {
        $gte: new Date(startDate),
        $lte: new Date(endDate)
      };
    }

    const bookings = await MealBooking.find(query)
      .sort({ date: -1 })
      .limit(limit * 1)
      .skip((page - 1) * limit)
      .populate('user', 'name studentId');

    const total = await MealBooking.countDocuments(query);

    res.json({
      status: 'success',
      data: {
        bookings,
        pagination: {
          page: parseInt(page),
          pages: Math.ceil(total / limit),
          total
        }
      }
    });
  } catch (error) {
    console.error('Get bookings error:', error);
    res.status(500).json({
      status: 'error',
      message: 'Server error'
    });
  }
});

// @route   GET /api/meals/count/:date
// @desc    Get meal count for staff (how many students booked)
// @access  Private (Staff/Admin)
router.get('/count/:date', [auth, authorize('staff', 'admin')], async (req, res) => {
  try {
    const { date } = req.params;
    
    const bookings = await MealBooking.find({
      date: new Date(date)
    });

    const count = {
      breakfast: bookings.filter(b => b.breakfast.booked).length,
      lunch: bookings.filter(b => b.lunch.booked).length,
      dinner: bookings.filter(b => b.dinner.booked).length,
      total: bookings.length
    };

    res.json({
      status: 'success',
      data: { count, date }
    });
  } catch (error) {
    console.error('Get meal count error:', error);
    res.status(500).json({
      status: 'error',
      message: 'Server error'
    });
  }
});

module.exports = router;

// .env file template
NODE_ENV=development
PORT=5000
MONGODB_URI=mongodb://localhost:27017/easymess
JWT_SECRET=your_super_secret_jwt_key_here_make_it_long_and_random
FRONTEND_URL=http://localhost:3000

# Email configuration (for notifications)
EMAIL_HOST=smtp.gmail.com
EMAIL_PORT=587
EMAIL_USER=your_email@gmail.com
EMAIL_PASS=your_app_password

# Payment gateway (optional)
RAZORPAY_KEY_ID=your_razorpay_key
RAZORPAY_KEY_SECRET=your_razorpay_secret